import pandas as pd
import numpy as np
import pefile
import time
from sklearn import tree
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler
# from sklearn.ensemble import RandomForestClassifier

clf = None

class Watcher:
    DIRECTORY_TO_WATCH = "C:\\"

    def __init__(self):
        self.observer = Observer()

    def run(self):
        event_handler = Handler()
        self.observer.schedule(event_handler, self.DIRECTORY_TO_WATCH, recursive=True)
        # self.observedPaths.append(path)
        self.observer.start()
        try:
            while True:
                time.sleep(5)
        except:
            self.observer.stop()
            print "Loi khong xac dinh"

        self.observer.join()

class Handler(FileSystemEventHandler):
    @staticmethod
    def on_any_event(event):
        if event.is_directory:
            return None
        elif event.event_type == 'created':
            if (event.src_path.endswith(".exe")):
				sample = ExtractSample(event.src_path)
				global clf
				result = Predict(sample, clf)
				if (result[0] == 0):
					print
					print "File co dau hieu nguy hiem"
					print "Path: ",event.src_path
				# print("%s %s" % (event.src_path,result))
                # print event.src_path

def get_resources(pe):	
	resources = []
	if hasattr(pe, 'DIRECTORY_ENTRY_RESOURCE'):
		try:
			for resource_type in pe.DIRECTORY_ENTRY_RESOURCE.entries:
				if hasattr(resource_type, 'directory'):
					for resource_id in resource_type.directory.entries:
						if hasattr(resource_id, 'directory'):
							for resource_lang in resource_id.directory.entries:
								data = pe.get_data(resource_lang.data.struct.OffsetToData, resource_lang.data.struct.Size)
								size = resource_lang.data.struct.Size
								entropy = get_entropy(data)
								resources.append([entropy, size])
		except Exception as e:
			return resources
	return resources

def get_version_info(pe):
	res = {}
	for fileinfo in pe.FileInfo:
		if fileinfo.Key == 'StringFileInfo':
			for st in fileinfo.StringTable:
				for entry in st.entries.items():
					res[entry[0]] = entry[1]
		if fileinfo.Key == 'VarFileInfo':
			for var in fileinfo.Var:
				res[var.entry.items()[0][0]] = var.entry.items()[0][1]
	if hasattr(pe, 'VS_FIXEDFILEINFO'):
		  res['flags'] = pe.VS_FIXEDFILEINFO.FileFlags
		  res['os'] = pe.VS_FIXEDFILEINFO.FileOS
		  res['type'] = pe.VS_FIXEDFILEINFO.FileType
		  res['file_version'] = pe.VS_FIXEDFILEINFO.FileVersionLS
		  res['product_version'] = pe.VS_FIXEDFILEINFO.ProductVersionLS
		  res['signature'] = pe.VS_FIXEDFILEINFO.Signature
		  res['struct_version'] = pe.VS_FIXEDFILEINFO.StrucVersion
	return res

def get_entropy(data):
	if len(data) == 0:
		return 0.0	
	occurences = array.array('L', [0]*256)
	for x in data:
  		occurences[x if isinstance(x, int) else ord(x)] += 1
	entropy = 0
	for x in occurences:
		if x:
			p_x = float(x) / len(data)
			entropy -= p_x*math.log(p_x, 2)
	return entropy

def ReadPEFile(path):
	res = {}
	pe = pefile.PE(path)
	res['Machine'] = pe.FILE_HEADER.Machine
	res['SizeOfOptionalHeader'] = pe.FILE_HEADER.SizeOfOptionalHeader
	res['Characteristics'] = pe.FILE_HEADER.Characteristics
	res['MajorLinkerVersion'] = pe.OPTIONAL_HEADER.MajorLinkerVersion
	res['MinorLinkerVersion'] = pe.OPTIONAL_HEADER.MinorLinkerVersion
	res['SizeOfCode'] = pe.OPTIONAL_HEADER.SizeOfCode
	res['SizeOfInitializedData'] = pe.OPTIONAL_HEADER.SizeOfInitializedData
	res['SizeOfUninitializedData'] = pe.OPTIONAL_HEADER.SizeOfUninitializedData
	res['AddressOfEntryPoint'] = pe.OPTIONAL_HEADER.AddressOfEntryPoint
	res['BaseOfCode'] = pe.OPTIONAL_HEADER.BaseOfCode
	try:
		res['BaseOfData'] = pe.OPTIONAL_HEADER.BaseOfData
	except AttributeError:
		res['BaseOfData'] = 0
	res['ImageBase'] = pe.OPTIONAL_HEADER.ImageBase
	res['SectionAlignment'] = pe.OPTIONAL_HEADER.SectionAlignment
	res['FileAlignment'] = pe.OPTIONAL_HEADER.FileAlignment
	res['MajorOperatingSystemVersion'] = pe.OPTIONAL_HEADER.MajorOperatingSystemVersion
	res['MinorOperatingSystemVersion'] = pe.OPTIONAL_HEADER.MinorOperatingSystemVersion
	res['MajorImageVersion'] = pe.OPTIONAL_HEADER.MajorImageVersion
	res['MinorImageVersion'] = pe.OPTIONAL_HEADER.MinorImageVersion
	res['MajorSubsystemVersion'] = pe.OPTIONAL_HEADER.MajorSubsystemVersion
	res['MinorSubsystemVersion'] = pe.OPTIONAL_HEADER.MinorSubsystemVersion
	res['SizeOfImage'] = pe.OPTIONAL_HEADER.SizeOfImage
	res['SizeOfHeaders'] = pe.OPTIONAL_HEADER.SizeOfHeaders
	res['CheckSum'] = pe.OPTIONAL_HEADER.CheckSum
	res['Subsystem'] = pe.OPTIONAL_HEADER.Subsystem
	res['DllCharacteristics'] = pe.OPTIONAL_HEADER.DllCharacteristics
	res['SizeOfStackReserve'] = pe.OPTIONAL_HEADER.SizeOfStackReserve
	res['SizeOfStackCommit'] = pe.OPTIONAL_HEADER.SizeOfStackCommit
	res['SizeOfHeapReserve'] = pe.OPTIONAL_HEADER.SizeOfHeapReserve
	res['SizeOfHeapCommit'] = pe.OPTIONAL_HEADER.SizeOfHeapCommit
	res['LoaderFlags'] = pe.OPTIONAL_HEADER.LoaderFlags
	res['NumberOfRvaAndSizes'] = pe.OPTIONAL_HEADER.NumberOfRvaAndSizes
	res['SectionsNb'] = len(pe.sections)
	entropy = map(lambda x:x.get_entropy(), pe.sections)
	res['SectionsMeanEntropy'] = sum(entropy)/float(len(entropy))
	res['SectionsMinEntropy'] = min(entropy)
	res['SectionsMaxEntropy'] = max(entropy)
	raw_sizes = map(lambda x:x.SizeOfRawData, pe.sections)
	res['SectionsMeanRawsize'] = sum(raw_sizes)/float(len(raw_sizes))
	res['SectionsMinRawsize'] = min(raw_sizes)
	res['SectionsMaxRawsize'] = max(raw_sizes)
	virtual_sizes = map(lambda x:x.Misc_VirtualSize, pe.sections)
	res['SectionsMeanVirtualsize'] = sum(virtual_sizes)/float(len(virtual_sizes))
	res['SectionsMinVirtualsize'] = min(virtual_sizes)
	res['SectionMaxVirtualsize'] = max(virtual_sizes)
	try:
		res['ImportsNbDLL'] = len(pe.DIRECTORY_ENTRY_IMPORT)
		imports = sum([x.imports for x in pe.DIRECTORY_ENTRY_IMPORT], [])
		res['ImportsNb'] = len(imports)
		res['ImportsNbOrdinal'] = len(filter(lambda x:x.name is None, imports))
	except AttributeError:
		res['ImportsNbDLL'] = 0
		res['ImportsNb'] = 0
		res['ImportsNbOrdinal'] = 0
	try:
		res['ExportNb'] = len(pe.DIRECTORY_ENTRY_EXPORT.symbols)
	except AttributeError:
		res['ExportNb'] = 0
	resources= get_resources(pe)
	res['ResourcesNb'] = len(resources)
	if len(resources)> 0:
		entropy = map(lambda x:x[0], resources)
		res['ResourcesMeanEntropy'] = sum(entropy)/float(len(entropy))
		res['ResourcesMinEntropy'] = min(entropy)
		res['ResourcesMaxEntropy'] = max(entropy)
		sizes = map(lambda x:x[1], resources)
		res['ResourcesMeanSize'] = sum(sizes)/float(len(sizes))
		res['ResourcesMinSize'] = min(sizes)
		res['ResourcesMaxSize'] = max(sizes)
	else:
		res['ResourcesNb'] = 0
		res['ResourcesMeanEntropy'] = 0
		res['ResourcesMinEntropy'] = 0
		res['ResourcesMaxEntropy'] = 0
		res['ResourcesMeanSize'] = 0
		res['ResourcesMinSize'] = 0
		res['ResourcesMaxSize'] = 0
	try:
		res['LoadConfigurationSize'] = pe.DIRECTORY_ENTRY_LOAD_CONFIG.struct.Size
	except AttributeError:
		res['LoadConfigurationSize'] = 0
	try:
		version_infos = get_version_info(pe)
		res['VersionInformationSize'] = len(version_infos.keys())
	except AttributeError:
		res['VersionInformationSize'] = 0
	return res

def ReadDataset():
	data = pd.read_csv('data.csv', sep='|')
	x = data.drop(['Name', 'md5', 'legitimate'], axis=1).values
	y = data['legitimate'].values
	clf = tree.DecisionTreeClassifier(max_depth=10)
	clf = clf.fit(x, y)
	return clf

def Predict(sample, clf):
	predicted = clf.predict(sample)
	return predicted

def ExtractSample(path):
	# path = r"C:\Users\hvk\Desktop\gravity.exe"
	res = ReadPEFile(path)
	sample = np.zeros((1, len(res)))
	sample[0][0] = res["Machine"]
	sample[0][1] = res["SizeOfOptionalHeader"]
	sample[0][2] = res["Characteristics"]
	sample[0][3] = res["MajorLinkerVersion"]
	sample[0][4] = res["MinorLinkerVersion"]
	sample[0][5] = res["SizeOfCode"]
	sample[0][6] = res["SizeOfInitializedData"]
	sample[0][7] = res["SizeOfUninitializedData"]
	sample[0][8] = res["AddressOfEntryPoint"]
	sample[0][9] = res["BaseOfCode"]
	sample[0][10] = res["BaseOfData"]
	sample[0][11] = res["ImageBase"]
	sample[0][12] = res["SectionAlignment"]
	sample[0][13] = res["FileAlignment"]
	sample[0][14] = res["MajorOperatingSystemVersion"]
	sample[0][15] = res["MinorOperatingSystemVersion"]
	sample[0][16] = res["MajorImageVersion"]
	sample[0][17] = res["MinorImageVersion"]
	sample[0][18] = res["MajorSubsystemVersion"]
	sample[0][19] = res["MinorSubsystemVersion"]
	sample[0][20] = res["SizeOfImage"]
	sample[0][21] = res["SizeOfHeaders"]
	sample[0][22] = res["CheckSum"]
	sample[0][23] = res["Subsystem"]
	sample[0][24] = res["DllCharacteristics"]
	sample[0][25] = res["SizeOfStackReserve"]
	sample[0][26] = res["SizeOfStackCommit"]
	sample[0][27] = res["SizeOfHeapReserve"]
	sample[0][28] = res["SizeOfHeapCommit"]
	sample[0][29] = res["LoaderFlags"]
	sample[0][30] = res["NumberOfRvaAndSizes"]
	sample[0][31] = res["SectionsNb"]
	sample[0][32] = res["SectionsMeanEntropy"]
	sample[0][33] = res["SectionsMinEntropy"]
	sample[0][34] = res["SectionsMaxEntropy"]
	sample[0][35] = res["SectionsMeanRawsize"]
	sample[0][36] = res["SectionsMinRawsize"]
	sample[0][37] = res["SectionsMaxRawsize"]
	sample[0][38] = res["SectionsMeanVirtualsize"]
	sample[0][39] = res["SectionsMinVirtualsize"]
	sample[0][40] = res["SectionMaxVirtualsize"]
	sample[0][41] = res["ImportsNbDLL"]
	sample[0][42] = res["ImportsNb"]
	sample[0][43] = res["ImportsNbOrdinal"]
	sample[0][44] = res["ExportNb"]
	sample[0][45] = res["ResourcesNb"]
	sample[0][46] = res["ResourcesMeanEntropy"]
	sample[0][47] = res["ResourcesMinEntropy"]
	sample[0][48] = res["ResourcesMaxEntropy"]
	sample[0][49] = res["ResourcesMeanSize"]
	sample[0][50] = res["ResourcesMinSize"]
	sample[0][51] = res["ResourcesMaxSize"]
	sample[0][52] = res["LoadConfigurationSize"]
	sample[0][53] = res["VersionInformationSize"]
	return sample

def main():
	global clf
	clf = ReadDataset()
	print '*'*70
	print "\t\t\tDang tien hanh giam sat"
	print '*'*70
	w = Watcher()
	w.run()

if __name__ == '__main__':
	main()


